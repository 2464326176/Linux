(1) sleep()会使线程进入阻塞状态，yield()不会时线程进入阻塞态而是进入可运行态，
当线程重新获得CPU执行权后又可以执行。

(2) sleep()释放CPU后其他都可以竞争CPU的执行权，
而yield()只会让线程优先级大于等于自己的线程竞争CPU执行权的机会。
线程2先启动，当运行到thread1.join()时，线程2停止运行，等待线程1执行结束，
虽然线程1启动比线程2迟，但是只有当线程1运行结束后，线程2才能继续运行。


join()可以保证让一个线程在另一个线程之前执行结束。
如何保证一个工作在另一个工作结束之前完成，就可以使用join()方法。
wait()可以让线程从运行态转换为阻塞态，同时还会释放线程的同步锁。

pthread_join用来等待一个线程的结束,线程间同步的操作;
创建一个线程默认的状态是joinable, 如果一个线程结束运行但没有被join,则它的状态类似于进程中的Zombie Process，
即还有一部分资源没有被回收（退出状态码），所以创建线程者应该pthread_join来等待线程运行结束，并可得到线程的退出代码，
回收其资源（类似于wait,waitpid)。

但是调用pthread_join后，如果该线程没有运行结束，调用者会被阻塞，在有些情况下我们并不希望如此，
比如在Web服务器中当主线程为每个新来的链接创建一个子线程进行处理的时候，主线程并不希望因为调用pthread_join而阻塞
（因为还要继续处理之后到来的链接），这时可以在子线程中加入代码pthread_datach脱离阻塞，这时候子线程状态为detached，
运行结束后会自动释放资源。

