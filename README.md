# Linux
Linux 网络编程
1、本地聊天室
    typedef struct node {
        char item[20];  //记录客户端名字
        int fifo_fd;  //该客户端使用的私有管道文件描述符(写端)
        struct node *next;	
    };
    
    发送包结构
    struct MesData {
        int protocal;
        char srcname[20];
        char destname[20];
        char data[100];
    };
    /*
     * protocal     srcname      destname      data
     * 1            登陆者       NULL
     * 2            发送方       接收方         数据
     * 3            NULL(不在线)
     * 4            退出登陆用户（退出登陆）
     */

  服务器 创建一个公共的命名管道（FIFO）,
        当A用户向B用户发送消息，若B在线，则服务器通过公共管道直接把信息传递给B
                              若B不在线，则服务器把信息写在B的私有管道
         用户可以登录/退出登录，服务器即时更新状态                       
  客户端 每个用户都拥有自己的私有管道，每次登录查询自己的私有管道，有消息则打印输出到显示屏
         可以随时给对方发送消息
2、多进程多线程并发通讯 
  使用tcp协议
  在服务器中父进程一直接受消息，创建子进程让其处理消息，子进程处理完 父进程结束子进程；
  在客户端，可支撑多个用户访问服务器
3、多进程copy
  采用共享映射区，源文件和目标文件分别建立映射区，并设置参数将映射信息反应在磁盘上，通过映射区数据的复制完成。
  若文件大小与进程个数不是整数，让前n-1个进程copy整数字节，最后一个进程处理剩余的；
  

在很多情况下，主线程生成并起动了子线程，如果子线程里要进行大量的耗时的运算，主线程往往将于子线程之前结束，但是如果主线程处理完其他的事务后，需要用到子线程的处理结果，也就是主线程需要等待子线程执行完成之后再结束，这个时候就要用到pthread_join()方法了。
即pthread_join()的作用可以这样理解：主线程等待子线程的终止。也就是在子线程调用了pthread_join()方法后面的代码，只有等到子线程结束了才能执行。

当A线程调用线程B并 pthread_join() 时，A线程会处于阻塞状态，直到B线程结束后，A线程才会继续执行下去。当 pthread_join() 函数返回后，被调用线程才算真正意义上的结束，它的内存空间也会被释放（如果被调用线程是非分离的）。这里有三点需要注意：

被释放的内存空间仅仅是系统空间，你必须手动清除程序分配的空间，比如 malloc() 分配的空间。
2.一个线程只能被一个线程所连接。
3.被连接的线程必须是非分离的，否则连接会出错。
所以可以看出pthread_join()有两种作用：

用于等待其他线程结束：当调用 pthread_join() 时，当前线程会处于阻塞状态，直到被调用的线程结束后，当前线程才会重新开始执行。

对线程的资源进行回收：如果一个线程是非分离的（默认情况下创建的线程都是非分离）并且没有对该线程使用 pthread_join() 的话，该线程结束后并不会释放其内存空间，这会导致该线程变成了“僵尸线程”。

作者：ZhangluO_O
链接：https://www.jianshu.com/p/a2ade02979d1
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。